#!/usr/bin/env python3
"""
weegfx/tools/bdfconv.py: Converts monospaced fonts in BDF format to C header files suitable for weegfx.

Copyright (c) 2019 Paolo Jovon <paolo.jovon@gmail.com>
Released under the 3-clause BSD license (see LICENSE)
"""

import os
import sys
import re
from argparse import ArgumentParser
from typing import TextIO, Iterable, Any, Callable

import bdf

MAX_H_COL = 80
"""Maximum column when generating the .h, after which to wrap."""


def emit_mono_bdf_header(record: bdf.BdfRecord, first_ch: int, last_ch: int, stream: TextIO):
    """Outputs a weegfx C header file storing a character range (`start_ch`..`end_ch`, both inclusive)
    of the FONT `record` to `stream`. Only accepts monospace fonts!"""

    def getval(record, key, default):
        return record.items.get(key, (default,))[0]

    def normname(name):
        return ''.join(ch if ch.isalnum() else '_' for ch in name)

    def hexbyte(byte):
        return f'0x{byte:02X}'

    if record.type != 'FONT':
        raise ValueError('Expected a FONT record in BDF')

    if first_ch > last_ch:
        first_ch, last_ch = first_ch, last_ch
    if not (0 <= first_ch <= 255) or not (0 <= last_ch <= 255):
        raise ValueError(
            'Invalid character range (note: non-ASCII chars are not yet supported!)')

    if len(record.children) < 1 or record.children[0].type != 'PROPERTIES':
        raise ValueError('Expected a PROPERTIES record in BDF')
    properties = record.children[0]

    font_w, font_h, font_ox, font_oy = bbox = record.items['FONTBOUNDINGBOX']
    font_family = getval(properties, 'FAMILY_NAME', '<unknown family>')
    font_weight = getval(properties, 'WEIGHT_NAME', '')

    h_varname = f'FONT_{normname(font_family.upper())}_{normname(font_weight.upper())}_{font_w}_{font_h}'
    h_guard = h_varname + '_H'

    h_data_size = bdf.bdf_width(font_w) // 8 * font_h * (last_ch - first_ch + 1)
    h_start = f"""// Autogenerated by weegfx/tools/bdfconv.py
// Only include this file ONCE in the codebase (every translation unit gets its copy of the font data!)
//
// Font: {getval(properties, 'FAMILY_NAME', '<unknown family>')} {font_w}x{font_h} {getval(properties, 'WEIGHT_NAME', '')}
//       {getval(record, 'FONT', '<unknown logical name>')}
//       Copyright {getval(properties, 'COPYRIGHT', '<no copyright info>')}
// Character range: {hexbyte(first_ch)}..{hexbyte(last_ch)} (both inclusive)
#ifndef {h_guard}
#define {h_guard}

static const WGFX_U8 {h_varname}_DATA[{h_data_size}] WGFX_RODATA = {{"""
    print(h_start, file=stream)

    # Table for faster lookups
    font_chars = {child.items['ENCODING'][0]: child
                  for child in record.children if child.type == 'CHAR'}

    bytes_per_row = bdf.bdf_width(font_w) // 8
    empty_char_bitmap = [0x00] * font_h * bytes_per_row

    for ich in range(first_ch, last_ch + 1):
        char_record = font_chars.get(ich, None)
        if char_record:
            char_bbox = char_record.items['BBX']
            if char_bbox[0] != font_w or char_bbox[1] != font_h:
                raise ValueError(
                    f'Character {ich} has wrong BBX, font is not monospace!')
            char_bitmap = char_record.items['BITMAP'].data
        else:
            print(f'Character {ich} missing, zero-filling pixel data',
                  file=sys.stderr)
            char_bitmap = empty_char_bitmap

        print(
            f'    // {hexbyte(ich)} {repr(chr(ich))}{" (MISSING)" * (not char_record)}', end='', file=stream)

        h_col = MAX_H_COL
        for byte in char_bitmap:
            if h_col >= MAX_H_COL:
                print('\n    ', file=stream, end='')
                h_col = 0
            print(hexbyte(byte) + ', ', end='', file=stream)

        print('', file=stream)

    h_end = f"""}};
    
static const WGFXmonoFont {h_varname} WGFX_RODATA = {{
    {font_w}, {font_h},
    {hexbyte(first_ch)}, {hexbyte(last_ch)},
    {h_varname}_DATA,
    {bdf.bdf_width(font_w) // 8 * font_h}, // = {bdf.bdf_width(font_w) // 8} * {font_h}
}};

#endif // {h_guard}"""
    print(h_end, file=stream)


if __name__ == '__main__':
    argp = ArgumentParser(
        description="Converts a BDF font to a C header suitable for weegfx")
    argp.add_argument('-o', '--outfile', type=str, required=False,
                      help="The file to output to (optional; defaults to stdout)")
    argp.add_argument('infile', type=str,
                      help='The BDF file to convert')
    argp.add_argument('firstch', type=int,
                      help="First character of the range of characters to output (inclusive)")
    argp.add_argument('lastch', type=int,
                      help="Last character of the range of characters to output (inclusive)")

    args = argp.parse_args()

    with open(args.infile, 'r') as infile:
        outfile = open(args.outfile, 'w') if args.outfile else sys.stdout
        with outfile:
            bdf_font = bdf.BdfRecord.parse_from(infile, 'FONT')
            emit_mono_bdf_header(bdf_font, args.firstch, args.lastch, outfile)
